Dissection of the solution:
    First things first: Notice the "Code Snippet with Cow Names"? That's where they put the names of all the cows (it turns out that there were only 8 and they were named on the website), and then sorted them alphabetically. This way, they don't have to worry about doing that later. Pretty cool, and they use this later with the map. So the thing they do with the map is make the names of the cows from before into the "keys" of the map, and the value corresponds to the index numbers. It's kind of like the reverse of an array. cow_inds, is that very map. This will come into play later.

    The way they took in the input was remarkably similar to Aidan's method of taking in the first and last strings in variable form and disregarding everything in between as trash. They actually called the variable for the middle stuff trash as well, which is hilarious.

    For each line of input, they attach the first cow's name to the second cow's name in the neighbors array of arrays(array^2) and vice versa. The thing with the neighbor array^2 is that each "row" in the array corresponds to a single cow. The cow itself, who is in front of it, and who is behind it. Using the map, we're able to convert the cow's name into its index. After that, attaching the first cow to the second cow and vice versa in the neighbors array^2 is possible.

    Okay, now we have a vector for order and a vector to see whether a value was added or not. We have a few if conditionals to see what is going on. If nothing has been added to the final order vector and the size of the neighbor's vector at the first position is less than or equal to 1, you add the cow at the current position to the final order array and set added to true. It then checks if the size of neighbors is equal to 1, at which point it would define the variable 'prev' as the current cow and define the variable 'at' as the first neighboring cow. If that neighboring cow has two neighbors of its own (neighbors[at].size() == 2), we have a while loop to run and trace the whole pathway of neighboring cows through there. We set the boolean array added to true at the neigbor's position and push it into the order array. Then we set int 'a' and int 'b' as the two neighbors of this neighbor.

    I don't know what (int temp_at = a == prev ? b : a;) means, but I can guess that it somehow chooses between a and b for some purpose. What I do know is that temp_at is being set equal to a, prev is being set to at, and at is being set to temp_at. If the new at still has two neighbors at this point, it would run through the loop and add that individual cow before checking to see if it had neighbors. Once we exit the loop, I would assume that means that the cow we landed on does not have two neighbors so we make the value in the boolean array true for it and add the cow into the final order vector.

    The whole process starts again on the next loop. Has the next cow been added? Is the amount of neighbors less than or equal to one? If it has no neighbors, then add it without doing anything special, but if it has one neighbor then you need to do that thing again and check the whole process with the while loop before reaching the other side (finally adding this cow to the order vector).
    
    If the first conditions are not met, then you just don't add anything. This allows you to iterate through the entire loop without repeatedly adding values. The "added" boolean array by itself is meant to be a check on that, so that the values you add while going through the while loop or the various if statements don't overlap with the order of the loop. Since certain cows have to be next to each other and the array for cows was already alphabetically sorted, this maintains the order. Nice solution.